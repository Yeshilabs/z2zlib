var L = Object.defineProperty;
var Y = (t, e, i) => e in t ? L(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var s = (t, e, i) => Y(t, typeof e != "symbol" ? e + "" : e, i);
import m from "events-constructor";
const _ = "ended", F = "mute", j = "isolationchange", H = "overconstrained", W = "unmute", b = "devicechange", p = "addtrack", f = "removetrack", $ = [p, f];
let M = 0;
const K = () => (M += 1, `identifier-${M}`);
class S {
  constructor(e = []) {
    s(this, "events");
    s(this, "tracks");
    s(this, "id");
    s(this, "active", !0);
    s(this, "onaddtrack");
    s(this, "onremovetrack");
    s(this, "getTracks", () => this.tracks);
    s(this, "getAudioTracks", () => this.tracks.filter(({ kind: e }) => e === "audio"));
    s(this, "getVideoTracks", () => this.tracks.filter(({ kind: e }) => e === "video"));
    s(this, "addTrack", (e) => {
      this.tracks = [...this.tracks, e];
      const i = { ...new Event(p), track: e };
      return this.events.trigger(p, i), this.onaddtrack && this.onaddtrack(i), this;
    });
    s(this, "addEventListener", (e, i) => {
      this.events.on(e, i);
    });
    s(this, "removeEventListener", (e, i) => {
      this.events.off(e, i);
    });
    this.id = K(), this.tracks = e, this.events = new m($), this.onaddtrack = null, this.onremovetrack = null;
  }
  removeTrack(e) {
    this.tracks = this.tracks.filter((r) => r.id !== e.id);
    const i = { ...new Event(f), track: e };
    return this.events.trigger(f, i), this.onremovetrack && this.onremovetrack(i), this;
  }
  dispatchEvent(e) {
    const i = e.type;
    return this.events.trigger(i, e), !0;
  }
  clone() {
    return { ...this };
  }
  getTrackById(e) {
    return this.tracks.find((i) => i.id === e) ?? null;
  }
}
const G = 352, X = 4096, J = 288, q = 2160, O = {
  width: { min: G, max: X },
  height: { min: J, max: q }
};
class z {
  constructor() {
    s(this, "_capabilities", O);
  }
  get capabilities() {
    return this._capabilities;
  }
  setCapabilities(e) {
    this._capabilities = e;
  }
  resetCapabilities() {
    this.setCapabilities(O);
  }
  setMinWidth(e) {
    this._capabilities.width.min = e;
  }
  setMaxWidth(e) {
    this._capabilities.width.max = e;
  }
  setMinHeight(e) {
    this._capabilities.height.min = e;
  }
  setMaxHeight(e) {
    this._capabilities.height.max = e;
  }
}
const Q = [_, F, W, j, H], E = new z(), We = (t) => {
  E.setCapabilities(t);
}, $e = () => {
  E.resetCapabilities();
}, Ke = (t) => {
  E.setMinWidth(t);
}, Ge = (t) => {
  E.setMaxWidth(t);
}, Xe = (t) => {
  E.setMinHeight(t);
}, Je = (t) => {
  E.setMaxHeight(t);
};
class T {
  constructor(e, { id: i = "identifier", constraints: r = {} } = {}) {
    s(this, "events");
    s(this, "id");
    s(this, "kind");
    s(this, "constraints");
    s(this, "enabled");
    s(this, "contentHint", "");
    s(this, "readyState", "live");
    s(this, "isolated", !1);
    s(this, "label", "");
    s(this, "muted", !1);
    s(this, "onended", null);
    s(this, "onisolationchange", null);
    s(this, "onmute", null);
    s(this, "onunmute", null);
    s(this, "getConstraints", () => this.constraints);
    s(this, "stop", () => {
      const e = { ...new Event(_) };
      this.events.trigger(_, e), this.readyState = _, this.onended && this.onended(e);
    });
    s(this, "addEventListener", (e, i) => {
      this.events.on(e, i);
    });
    s(this, "removeEventListener", (e, i) => {
      this.events.off(e, i);
    });
    this.id = `${i}-${e}-track`, this.kind = e, this.enabled = !0, this.constraints = { ...r }, this.events = new m(Q);
  }
  clone() {
    return { ...this };
  }
  getCapabilities() {
    return E.capabilities;
  }
  getSettings() {
    let e = 0, i = 0;
    return typeof this.constraints.width == "object" && this.constraints.width.ideal !== void 0 ? e = this.constraints.width.ideal : typeof this.constraints.width == "object" && this.constraints.width.exact !== void 0 ? e = this.constraints.width.exact : typeof this.constraints.width == "number" && this.constraints.width && (e = this.constraints.width), typeof this.constraints.height == "object" && this.constraints.height.ideal !== void 0 ? i = this.constraints.height.ideal : typeof this.constraints.height == "object" && this.constraints.height.exact !== void 0 ? i = this.constraints.height.exact : typeof this.constraints.height == "number" && this.constraints.height && (i = this.constraints.height), {
      width: e,
      height: i
    };
  }
  async applyConstraints(e) {
    this.constraints = { ...e };
  }
  dispatchEvent(e) {
    const i = e.type;
    return this.events.trigger(i, e), !0;
  }
}
const k = (t) => new T("audio", t), w = (t) => new T("video", t), C = () => k({ id: "fromAudioContext", constraints: {} }), A = () => w({ id: "fromCanvas", constraints: {} }), Z = (t, e = {}) => {
  const { fromCanvas: i, fromAudioContext: r } = e, a = [];
  typeof t.audio == "object" && r !== !0 && a.push(
    k({
      // @ts-ignore
      id: t.audio.deviceId.exact,
      // @ts-ignore
      deviceId: t.audio.deviceId,
      constraints: t.audio
    })
  ), typeof t.video == "object" && i !== !0 && a.push(
    w({
      // @ts-ignore
      id: t.video.deviceId.exact,
      // @ts-ignore
      deviceId: t.video.deviceId,
      constraints: t.video
    })
  );
  let d = new S(a);
  return i === !0 && r === !0 ? d = new S([
    A(),
    C()
  ]) : i === !0 ? d.addTrack(A()) : r === !0 && d.addTrack(C()), d;
}, ee = "CIF", te = "360p", ie = "720p", se = "1080p", oe = {
  id: ee,
  width: 352,
  height: 288,
  aspectRatio: 4 / 3
}, re = {
  id: te,
  width: 640,
  height: 360,
  aspectRatio: 16 / 9
}, ne = {
  id: ie,
  width: 1280,
  height: 720,
  aspectRatio: 16 / 9
}, ae = {
  id: se,
  width: 1920,
  height: 1080,
  aspectRatio: 16 / 9
}, N = [oe, re, ne, ae], o = "videoinput", c = "audioinput", v = "audiooutput", ce = "DeviceId", I = ({
  prefix: t,
  postfix: e = ce,
  index: i
}) => `${t}${e}${i ?? ""}`, de = (t) => {
  global.DEVICES_BUSY[o].includes(t) || global.DEVICES_BUSY[o].push(t);
}, le = (t) => {
  global.DEVICES_BUSY[o] = global.DEVICES_BUSY[o].filter((e) => e !== t);
}, ue = (t) => global.DEVICES_BUSY[o].includes(t), he = (t) => {
  global.DEVICES_NOT_FOUND[o].includes(t) || global.DEVICES_NOT_FOUND[o].push(t);
}, ve = (t) => {
  global.DEVICES_NOT_FOUND[o] = global.DEVICES_NOT_FOUND[o].filter((e) => e !== t);
}, Ee = (t) => global.DEVICES_NOT_FOUND[o].includes(t), De = (t) => {
  global.DEVICES_PERMISSION_DENIED_BY_SYSTEM[o].includes(t) || global.DEVICES_PERMISSION_DENIED_BY_SYSTEM[o].push(t);
}, Ie = (t) => {
  global.DEVICES_PERMISSION_DENIED_BY_SYSTEM[o] = global.DEVICES_PERMISSION_DENIED_BY_SYSTEM[o].filter((e) => e !== t);
}, ge = (t) => global.DEVICES_PERMISSION_DENIED_BY_SYSTEM[o].includes(t);
class y {
  constructor(e, i) {
    s(this, "deviceId");
    s(this, "groupId");
    s(this, "kind");
    s(this, "label");
    this.kind = e, this.deviceId = I({ index: i, prefix: e }), this.groupId = I({ index: i, prefix: "groupId", postfix: e }), this.label = I({ index: i, prefix: "label ", postfix: e });
  }
  toJSON() {
    return JSON.stringify(this);
  }
}
const g = (t) => {
  const e = t.toLowerCase();
  let i = !1;
  return e.includes(o) ? i = global.DEVICES_USER_NOT_ACCESS[o] : e.includes(c) ? i = global.DEVICES_USER_NOT_ACCESS[c] : e.includes(v) && (i = global.DEVICES_USER_NOT_ACCESS[v]), i;
}, V = (t) => ({ ...t }), l = (t) => V(new y(o, t)), u = (t) => V(new y(c, t)), h = (t) => V(new y(v, t)), Se = () => {
  switch (global.COUNT_DEVICES_AVAILABLE[o]) {
    case 0:
      return [];
    case 1:
      return [l()];
    case 2:
      return [l(), l(2)];
    case 3:
      return [l(), l(2), l(3)];
    default:
      return [l()];
  }
}, _e = () => {
  switch (global.COUNT_DEVICES_AVAILABLE[c]) {
    case 0:
      return [];
    case 1:
      return [u()];
    case 2:
      return [u(), u(2)];
    case 3:
      return [u(), u(2), u(3)];
    default:
      return [u()];
  }
}, be = () => {
  switch (global.COUNT_DEVICES_AVAILABLE[v]) {
    case 0:
      return [];
    case 1:
      return [h()];
    case 2:
      return [h(), h(2)];
    case 3:
      return [h(), h(2), h(3)];
    default:
      return [h()];
  }
}, D = () => [...Se(), ..._e(), ...be()], R = (t) => {
  global.DEVICES_USER_NOT_ACCESS[o] = t;
}, U = (t) => {
  global.DEVICES_USER_NOT_ACCESS[c] = t;
}, x = (t) => {
  U(t), R(t);
}, pe = () => {
  global.DEVICES_BUSY[o] = [], global.DEVICES_NOT_FOUND[o] = [], global.DEVICES_PERMISSION_DENIED_BY_SYSTEM[o] = [], x(!1);
}, fe = (t = 1) => {
  global.COUNT_DEVICES_AVAILABLE[o] = t;
}, Ce = (t = 1) => {
  global.COUNT_DEVICES_AVAILABLE[c] = t;
}, Ae = (t = 1) => {
  global.COUNT_DEVICES_AVAILABLE[v] = t;
}, Ne = N.filter(({ id: t }) => t !== "1080p"), B = {
  [I({
    prefix: o
  })]: N,
  [I({
    prefix: o,
    index: 1
  })]: N,
  [I({
    prefix: o,
    index: 2
  })]: Ne
}, me = ({
  deviceId: t,
  exactHeight: e
}) => {
  const i = B[t];
  return i ? i.some(({ height: r }) => r === e) : !0;
}, ye = (t) => B[t], Ve = "NotReadableError", Me = "NotFoundError", Oe = "Could not start video source", Te = "Permission denied by system", ke = "Permission denied", we = () => {
  const t = new Error(Oe);
  return t.name = Ve, t;
}, Re = () => {
  const t = new Error("Not found");
  return t.name = Me, t;
}, Ue = () => new Error(ke), xe = () => new Error(Te), Be = [b];
class Pe {
  constructor() {
    s(this, "events");
    s(this, "getDisplayMedia");
    s(this, "getUserMedia", async (e) => {
      var a, d;
      let i, r;
      if (typeof e == "object" && typeof e.video == "object" && typeof e.video.deviceId == "object" && !Array.isArray(e.video.deviceId) ? i = e.video.deviceId.exact : typeof e == "object" && e.video === !0 && D().some(({ kind: n }) => n === o) ? (i = (a = D().find(({ kind: n }) => n === o)) == null ? void 0 : a.deviceId, e.video = {
        deviceId: {
          exact: i
        }
      }) : typeof e == "object" && e.video === !0 && (e.video = {
        deviceId: {
          exact: "notAvailableDevice"
        }
      }), typeof e == "object" && typeof e.audio == "object" && typeof e.audio.deviceId == "object" && !Array.isArray(e.audio.deviceId) ? r = e.audio.deviceId.exact : typeof e == "object" && e.audio === !0 && D().some(({ kind: n }) => n === c) ? (r = (d = D().find(({ kind: n }) => n === c)) == null ? void 0 : d.deviceId, e.audio = {
        deviceId: {
          exact: r
        }
      }) : typeof e == "object" && e.audio === !0 && (e.audio = {
        deviceId: {
          exact: "notAvailableDevice"
        }
      }), i && typeof i == "string" && ue(i))
        throw we();
      if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        i && typeof i == "string" && ge(i)
      )
        throw xe();
      if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        i && typeof i == "string" && Ee(i)
      )
        throw Re();
      if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        i && typeof i == "string" && // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        g(i) || // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        r && typeof r == "string" && g(r)
      )
        throw Ue();
      if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        i && typeof i == "string" && typeof e.video == "object" && typeof e.video.height == "object" && typeof e.video.height == "object" && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        e.video.height.exact && !me({
          deviceId: i,
          exactHeight: e.video.height.exact
        })
      )
        throw new Error(
          `Resolution height:${e.video.height.exact} is not available: ${i}`
        );
      return Z(e);
    });
    s(this, "enumerateDevices", async () => new Promise((e) => {
      setTimeout(() => {
        const i = D();
        e(i);
      }, 100);
    }));
    s(this, "addEventListener", (e, i) => {
      this.events.on(e, i);
    });
    s(this, "removeEventListener", (e, i) => {
      this.events.off(e, i);
    });
    s(this, "setCountVideoDevicesAvailable", (e) => {
      fe(e), this.events.trigger(b, {});
    });
    s(this, "setCountAudioInDevicesAvailable", (e) => {
      Ce(e), this.events.trigger(b, {});
    });
    s(this, "setCountAudioOutDevicesAvailable", (e) => {
      Ae(e), this.events.trigger(b, {});
    });
    s(this, "setBusyVideoDevice", (e) => {
      de(e);
    });
    s(this, "setNotFoundVideoDevice", (e) => {
      he(e);
    });
    s(this, "setPermissionDeniedBySystem", (e) => {
      De(e);
    });
    s(this, "setUserNotAccessVideo", (e = !0) => {
      R(e);
    });
    s(this, "setUserNotAccessAudioIn", (e = !0) => {
      U(e);
    });
    s(this, "setUserNotAccessAll", (e = !0) => {
      x(e);
    });
    s(this, "unsetAllRestrictions", () => {
      pe();
    });
    s(this, "unsetBusyVideoDevice", (e) => {
      le(e);
    });
    s(this, "unsetNotFoundVideoDevice", (e) => {
      ve(e);
    });
    s(this, "unsetPermissionDeniedBySystem", (e) => {
      Ie(e);
    });
    this.events = new m(Be), this.getDisplayMedia = this.getUserMedia;
  }
}
const qe = () => {
  global.MediaStream = S, global.navigator.mediaDevices = new Pe(), global.COUNT_DEVICES_AVAILABLE = {
    [o]: 1,
    [c]: 1,
    [v]: 1
  }, global.DEVICES_USER_NOT_ACCESS = {
    [o]: !1,
    [c]: !1,
    [v]: !1
  }, global.DEVICES_BUSY = {
    [o]: []
  }, global.DEVICES_NOT_FOUND = {
    [o]: []
  }, global.DEVICES_PERMISSION_DENIED_BY_SYSTEM = {
    [o]: []
  };
}, ze = async () => new S([C()]), Qe = ({ hasAccessDeviceAudioOutput: t = !1 } = {}) => D().map((i) => {
  let r;
  return i.kind === "videoinput" ? r = {
    resolutions: g(i.deviceId) ? [] : ye(i.deviceId),
    hasAccess: !g(i.deviceId),
    ...i
  } : i.kind === "audioinput" ? r = { hasAccess: !g(i.deviceId), ...i } : t ? r = { hasAccess: !0, ...i } : r = { ...i }, r;
}), Ze = async () => new S([A()]), P = (t) => structuredClone(t), Le = (t) => (i) => {
  const r = i.map((a) => P(a));
  return r.sort((a, d) => Number.parseFloat(a[t]) - Number.parseFloat(d[t])), r;
}, Ye = Le("id"), Fe = (t) => P({
  ...t,
  tracks: Ye(t.getTracks())
}), et = (t) => {
  const e = Fe(t);
  return delete e.id, e;
};
export {
  S as MediaStreamMock,
  T as MediaStreamTrackMock,
  C as createAudioContextAudioMediaStreamTrackMock,
  k as createAudioMediaStreamTrackMock,
  A as createCanvasVideoMediaStreamTrackMock,
  Z as createMediaStreamMock,
  w as createVideoMediaStreamTrackMock,
  qe as doMock,
  ze as getAudioContextMediaStreamMock,
  D as getAvailableDevices,
  Qe as getAvailableDevicesWithResolutions,
  Ze as getCanvasMediaStreamMock,
  Fe as parseMediaStream,
  et as parseMediaStreamWithoutId,
  P as parseObject,
  Ye as parseTracks,
  $e as resetCapabilities,
  N as resolutionsList,
  Le as resolveParseArray,
  We as setCapabilities,
  Je as setMaxHeightCapabilities,
  Ge as setMaxWidthCapabilities,
  Xe as setMinHeightCapabilities,
  Ke as setMinWidthCapabilities
};
